{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>To install the latest released version: <pre><code>pip install sqly[migration]\n</code></pre></p> <p>To install the current development version: <pre><code>pip install git+https://github.com/kruxia/sqly@main#egg=sqly[migration]\n</code></pre></p>"},{"location":"#project-documentation","title":"Project Documentation","text":"<ul> <li>Basic Usage \u2014 An example of using SQLY to interact with a   database.</li> <li>CLI Usage \u2014 When the Python <code>sqly</code> package is installed in     the local environment, it can be used as a shell command. </li> <li>Reference \u2014 code reference documentation.</li> </ul>"},{"location":"basic-usage/","title":"Basic Usage","text":"<p>Once sqly is installed in your environment, you can:</p> <ul> <li>use the CLI to manage database migrations. See CLI Usage.</li> <li>use the <code>sqly</code> module to manage your interactions with a SQL database.</li> </ul> <p>Here is an example session working with sqly. Let\u2019s assume that our python project is called <code>my_project</code> and we\u2019re in the package directory in the shell. We\u2019re going to use a SQLite database in a file called <code>my_project.db</code>. </p> <p>First, let\u2019s create a table called <code>products</code> using sqly migrations. </p> <pre><code>$ sqly migration my_app -n products\nCreated migration: my_app:20230726163514429_products\n    depends:\n      - sqly:20211105034808482_init\n</code></pre> <p>Now we can edit the created YAML file: <pre><code># my_app/migrations/20230726163514429_products.yaml\napp: my_app\nts: 20230726163514429\nname: products\ndepends:\n- sqly:20211105034808482_init\ndoc: null\nup: - |-\nCREATE TABLE products (\nid        integer PRIMARY KEY AUTOINCREMENT,\nname      varchar NOT NULL,\nsku       varchar NOT NULL UNIQUE,\ncreated   datetime DEFAULT current_timestamp\n);\ndn: - DROP TABLE products;\n</code></pre></p> <p>Now we can apply the migration using the migration key, <code>my_app:20230726163514429_products</code>. It\u2019s also useful to define the DATABASE_URL and DATABASE_DIALECT in the environment so we don\u2019t have to pass them as commandline parameters and so we can use them in Python. (This is where I usually recommend using the excellent direnv to manage project-level environment variables. Just make sure to add the <code>.envrc</code> file to your <code>.gitignore</code>.) <pre><code>$ export DATABASE_URL=my_app.db &gt;&gt;.envrc\n$ export DATABASE_DIALECT=sqlite &gt;&gt;.envrc\n$ direnv allow\n...\n$ sqly migrate my_app:20230726163514429_products\nno such table: sqly_migrations\nsqly:20211105034808482_init up ... OK\nmy_app:20230726163514429_products up ... OK\n</code></pre> The first time migrations are run, there is not yet a <code>sqly_migrations</code> table, but that\u2019s ok: the sqly init migration creates it. </p> <p>If we want to make changes to our products migration, we can roll it back, change the YAML, and the re-migrate up. The way to roll back is to select the migration we want to migrate to \u2013 in this case, the sqly init migration: <pre><code>$ sqly migrate sqly:20211105034808482_init my_app:20230726163514429_products dn ... OK\n$ # ... make some changes ...\n$ sqly migrate my_app:20230726163514429_products\nmy_app:20230726163514429_products up ... OK\n</code></pre></p> <p>Now that we have a database with a table, we can interact with it in our application code.</p> <pre><code>import os\nfrom sqly import SQL, queries\nDATABASE_DIALECT = os.environ['DATABASE_DIALECT']\nDATABASE_URL = os.environ['DATABASE_URL']\n# set up the database connection and SQL interface\nsql = SQL(dialect=DATABASE_DIALECT)\nadaptor = sql.dialect.adaptor()\nconn = adaptor.connect(DATABASE_URL)\n# insert some products\nproducts = [\n{'name': 'cheese grater', 'sku': 'product-01'},\n{'name': 'cheese slicer', 'sku': 'product-02'},\n{'name': 'fondue pot', 'sku': 'product-03'},\n]\nfor product in products:\nsql.execute(conn, queries.INSERT('products', product), product)\nconn.commit()\n# select some products\ncheese_products = sql.select(\nconn, \nqueries.SELECT(\n'products', \nfilters=[\"name like :pattern\"]\n), \n{'pattern': 'cheese%'},\n)\nfor product in cheese_products:\nprint(product)\n# {'id': 1, 'name': 'cheese grater', 'sku': 'product-01', 'created': ...}\n# {'id': 2, 'name': 'cheese slicer', 'sku': 'product-02', 'created': ...}\n# delete a product that no self-respecting cheeseshop would carry\nsql.execute(\nconn, \nqueries.DELETE('products', filters=[\"name like :pattern\"]), {'pattern': 'fondue%'},\n)\n# on second thought, let's just rename it so it's more cheesy\nconn.rollback()\nsql.execute(\nconn,\nqueries.UPDATE(\n'products', \n['name'], \nfilters=[\"name like :pattern\"], \n),\n{'name': 'cheese melter', 'pattern': 'fondue%'}\n)\nconn.commit()\n</code></pre>"},{"location":"cli/","title":"CLI Usage","text":"<p>This page provides documentation for the sqly command line command. </p> <ul> <li> <p><code>sqly migration</code> = create a new migration. Example:   <pre><code>$ sqly migration APP_NAME -n MIGRATION_NAME\nCreated migration: APP_NAME:20230725235258975_MIGRATION_NAME\n    depends:\n      - sqly:20211105034808482_init\n</code></pre></p> </li> <li> <p><code>sqly migrations</code> = list the migrations. Example:   <pre><code>$ sqly migrations APP_NAME\nAPP_NAME:20230725235258975_MIGRATION_NAME\n</code></pre></p> </li> <li> <p><code>sqly migrate</code> = migrate the database to a migration. Example:   <pre><code>$ sqly migrate APP_NAME:20230725235258975_MIGRATION_NAME\n...\nsqly:20211105034808482_init up ... OK\nAPP_NAME:20230725235258975_MIGRATION_NAME up ... OK\n</code></pre></p> </li> </ul>"},{"location":"cli/#sqly","title":"sqly","text":"<p>Usage:</p> <pre><code>sqly [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#sqly-migrate","title":"sqly migrate","text":"<p>Migrate database_url to the given MIGRATION_KEY (up or dn).</p> <p>Usage:</p> <pre><code>sqly migrate [OPTIONS] MIGRATION_KEY\n</code></pre> <p>Options:</p> Name Type Description Default <code>-u</code>, <code>--database-url</code> text Datebase to migrate; default = env $DATABASE_URL None <code>-d</code>, <code>--dialect</code> text N/A None <code>-r</code>, <code>--dryrun</code> boolean If present, shows but does not run the migrations <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#sqly-migration","title":"sqly migration","text":"<p>Create a Migration in APP (importable python module) incorporating dependencies from OTHER_APPS</p> <p>Usage:</p> <pre><code>sqly migration [OPTIONS] APP [OTHER_APPS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--name</code> text A couple words describing the Migration\u2019s purpose None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#sqly-migrations","title":"sqly migrations","text":"<p>List the Migrations in APPS</p> <p>Usage:</p> <pre><code>sqly migrations [OPTIONS] [APPS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>-i</code>, <code>--include-depends</code> boolean Include dependencies <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"reference/","title":"sqly","text":"<ul> <li> <p>[<code>sqly.__main__</code>][] \u2014 Code documentation for the <code>sqly</code> CLI command. (Usage docs   here.)</p> </li> <li> <p>[<code>sqly.dialect</code>][] \u2014 Definitions for supported SQL database dialects and adaptors.</p> </li> <li> <p>[<code>sqly.lib</code>][] \u2014 Internal functions.</p> </li> <li> <p>[<code>sqly.migration</code>][] \u2014 Migration system.</p> </li> <li> <p>[<code>sqly.queries</code>][] \u2014 A set of basic \u201cCRUD\u201d queries for simple cases.</p> </li> <li> <p>[<code>sqly.query</code>][] \u2014 The <code>Q</code> helper class for building SQL queries.</p> </li> <li> <p>[<code>sqly.sql</code>][] \u2014 SQL interface class for rendering and executing ergonomic database   queries.</p> </li> </ul>"},{"location":"reference/sqly.__main__/","title":"<code>sqly.__main__</code>","text":"<p>The <code>sqly.__main__</code> module provides the <code>sqly</code> command line command. This is the code reference documentation; see the CLI Usage document for usage information.</p>"},{"location":"reference/sqly.__main__/#sqly.__main__.migrate","title":"<code>migrate(migration_key, database_url=None, dialect=None, dryrun=False)</code>","text":"<p>Migrate database_url to the given MIGRATION_KEY (up or dn).</p> Source code in <code>sqly/__main__.py</code> <pre><code>@sqly.command()\n@click.argument(\"migration_key\")\n@click.option(\n\"-u\",\n\"--database-url\",\nrequired=False,\nhelp=\"Datebase to migrate; default = env $DATABASE_URL\",\n)\n@click.option(\"-d\", \"--dialect\", required=False)\n@click.option(\n\"-r\",\n\"--dryrun\",\nis_flag=True,\nhelp=\"If present, shows but does not run the migrations\",\n)\ndef migrate(migration_key, database_url=None, dialect=None, dryrun=False):\n\"\"\"\n    Migrate database_url to the given MIGRATION_KEY (up or dn).\n    \"\"\"\ndatabase_url = database_url or os.getenv(\"DATABASE_URL\")\ndialect = dialect or os.getenv(\"DATABASE_DIALECT\")\nif not database_url:\nprint(\"--database-url or env $DATABASE_URL must be set\", file=sys.stderr)\nsys.exit(1)\nif not dialect:\nprint(\"--dialect or env $DATABASE_DIALECT must be set\", file=sys.stderr)\nsys.exit(1)\ndialect = Dialect(dialect)\nadaptor = dialect.adaptor()\n# if dialect == Dialect.MYSQL:\n#     conn_info = json.loads(database_url)\n#     connection = adaptor.connect(**conn_info)\n# else:\nconnection = adaptor.connect(database_url)\nmigration = Migration.key_load(migration_key)\nMigration.migrate(connection, dialect, migration, dryrun=dryrun)\n</code></pre>"},{"location":"reference/sqly.__main__/#sqly.__main__.migration","title":"<code>migration(app, other_apps, name)</code>","text":"<p>Create a Migration in APP (importable python module) incorporating dependencies from OTHER_APPS</p> Source code in <code>sqly/__main__.py</code> <pre><code>@sqly.command()\n@click.option(\n\"-n\",\n\"--name\",\nrequired=False,\nhelp=\"A couple words describing the Migration's purpose\",\n)\n@click.argument(\"app\")\n@click.argument(\"other_apps\", nargs=-1)\ndef migration(app, other_apps, name):\n\"\"\"\n    Create a Migration in APP (importable python module) incorporating dependencies from\n    OTHER_APPS\n    \"\"\"\nmigration = Migration.create(app, *other_apps, name=name)\nmigration.save(exclude={\"applied\"})\nprint(f\"Created migration: {migration.key}\")\nprint(\"    depends:\\n      -\", \"\\n      - \".join(migration.depends or \"[]\"))\n</code></pre>"},{"location":"reference/sqly.__main__/#sqly.__main__.migrations","title":"<code>migrations(apps, include_depends=False)</code>","text":"<p>List the Migrations in APPS</p> Source code in <code>sqly/__main__.py</code> <pre><code>@sqly.command()\n@click.argument(\"apps\", nargs=-1)\n@click.option(\"-i\", \"--include-depends\", is_flag=True, help=\"Include dependencies\")\ndef migrations(apps, include_depends=False):\n\"\"\"\n    List the Migrations in APPS\n    \"\"\"\nfor app in apps:\napp_migrations = Migration.app_migrations(app, include_depends=include_depends)\ngraph = Migration.graph(Migration.app_migrations(app, include_depends=True))\nfor key in nx.lexicographical_topological_sort(graph):\nif key in app_migrations:\nprint(key)\nmigration = app_migrations[key]\nif migration.depends and include_depends:\nprint(\"\\t=&gt; \" + \"\\n\\t=&gt; \".join(migration.depends))\n</code></pre>"},{"location":"reference/sqly.dialect/","title":"sqly.dialect","text":"<p>Definitions for different dialects of SQL databases. Each Dialect:</p> <ul> <li>is named for its database adaptor (driver module).</li> <li>defines an ParamFormat that the Dialect uses to   render queries with parameters.</li> <li>has an <code>adaptor()</code> method that imports and returns    the adaptor itself.</li> </ul> <p>Examples:</p> <p>List the supported Dialects:</p> <pre><code>&gt;&gt;&gt; for dialect in Dialect.__members__.values(): print(repr(dialect))\n&lt;Dialect.PSYCOPG: 'psycopg'&gt;\n&lt;Dialect.SQLITE: 'sqlite'&gt;\n</code></pre> <p>Interact with one of the Dialects:</p> <pre><code>&gt;&gt;&gt; from sqly import Dialect\n&gt;&gt;&gt; dialect = Dialect(\"psycopg\")\n&gt;&gt;&gt; dialect.param_format\n&lt;ParamFormat.PYFORMAT: '%(field)s'&gt;\n&gt;&gt;&gt; dialect.param_format.is_keyed\nTrue\n&gt;&gt;&gt; dialect.adaptor_name\n'psycopg'\n&gt;&gt;&gt; dialect.adaptor()\n&lt;module 'psycopg' from '.../psycopg/__init__.py'&gt;\n</code></pre>"},{"location":"reference/sqly.dialect/#sqly.dialect.Dialect","title":"<code>Dialect</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Each Dialect is named for the adaptor (driver) interface that it uses and encapsulates the options that adaptor uses for such things as query parameter formatting.</p> Source code in <code>sqly/dialect.py</code> <pre><code>class Dialect(Enum):\n\"\"\"\n    Each Dialect is named for the adaptor (driver) interface that it uses and\n    encapsulates the options that adaptor uses for such things as query parameter\n    formatting.\n    \"\"\"\nPSYCOPG = \"psycopg\"\nSQLITE = \"sqlite\"\n# --\n# MYSQL = \"mysql\"\n# PYODBC = \"pyodbc\"\n# # --\n# ASYNCPG = \"asyncpg\"\n# DATABASES = \"databases\"\n# SQLALCHEMY = \"sqlalchemy\"\n# PSYCOPG2 = \"psycopg2\"\n@property\ndef param_format(self) -&gt; ParamFormat:\n\"\"\"The [ParamFormat](./#sqly.dialect.ParamFormat) for this Dialect.\"\"\"\nreturn {\n\"psycopg\": ParamFormat.PYFORMAT,\n\"sqlite\": ParamFormat.QMARK,\n# --\n# \"mysql\": ParamFormat.FORMAT,\n# \"pyodbc\": ParamFormat.QMARK,\n# # --\n# \"asyncpg\": ParamFormat.NUMBERED,\n# \"databases\": ParamFormat.NAMED,\n# \"sqlalchemy\": ParamFormat.PYFORMAT,\n# \"psycopg2\": ParamFormat.PYFORMAT,\n}[self.value]\n@property\ndef adaptor_name(self) -&gt; str:\n\"\"\"The name of the adaptor (driver module) to import for this Dialect.\"\"\"\nreturn {\n\"psycopg\": \"psycopg\",\n\"sqlite\": \"sqlite3\",\n# --\n# \"mysql\": \"MySQLdb\",\n# \"pyodbc\": \"pyodbc\",\n# # --\n# \"asyncpg\": \"asyncpg\",\n# \"databases\": \"databases\",\n# \"sqlalchemy\": \"sqlalchemy\",\n# \"psycopg2\": \"psycopg2\",\n}[self.value]\ndef adaptor(self) -&gt; Any:\n\"\"\"The adaptor (driver module) itself for this Dialect.\n        Returns:\n            (Any): A database adaptor (driver module).\n        \"\"\"\nreturn import_module(self.adaptor_name)\n</code></pre>"},{"location":"reference/sqly.dialect/#sqly.dialect.Dialect.adaptor_name","title":"<code>adaptor_name: str</code>  <code>property</code>","text":"<p>The name of the adaptor (driver module) to import for this Dialect.</p>"},{"location":"reference/sqly.dialect/#sqly.dialect.Dialect.param_format","title":"<code>param_format: ParamFormat</code>  <code>property</code>","text":"<p>The ParamFormat for this Dialect.</p>"},{"location":"reference/sqly.dialect/#sqly.dialect.Dialect.adaptor","title":"<code>adaptor()</code>","text":"<p>The adaptor (driver module) itself for this Dialect.</p> <p>Returns:</p> Type Description <code>Any</code> <p>A database adaptor (driver module).</p> Source code in <code>sqly/dialect.py</code> <pre><code>def adaptor(self) -&gt; Any:\n\"\"\"The adaptor (driver module) itself for this Dialect.\n    Returns:\n        (Any): A database adaptor (driver module).\n    \"\"\"\nreturn import_module(self.adaptor_name)\n</code></pre>"},{"location":"reference/sqly.dialect/#sqly.dialect.ParamFormat","title":"<code>ParamFormat</code>","text":"<p>             Bases: <code>Enum</code></p> <p>The parameter format for a given database dialect.</p> Source code in <code>sqly/dialect.py</code> <pre><code>class ParamFormat(Enum):\n\"\"\"\n    The parameter format for a given database dialect.\n    \"\"\"\n# -- positional --\nQMARK = \"?\"\nFORMAT = \"%s\"\nNUMBERED = \"$i\"\n# -- keyed --\nNAMED = \":field\"\nPYFORMAT = \"%(field)s\"\n@property\ndef is_keyed(self) -&gt; bool:\n\"\"\"If true, this `ParamFormat` uses keyword parameters.\"\"\"\nreturn self in {self.NAMED, self.PYFORMAT}\n@property\ndef is_positional(self) -&gt; bool:\n\"\"\"If true, this `ParamFormat` uses positional parameters.\"\"\"\nreturn not self.is_keyed\n</code></pre>"},{"location":"reference/sqly.dialect/#sqly.dialect.ParamFormat.is_keyed","title":"<code>is_keyed: bool</code>  <code>property</code>","text":"<p>If true, this <code>ParamFormat</code> uses keyword parameters.</p>"},{"location":"reference/sqly.dialect/#sqly.dialect.ParamFormat.is_positional","title":"<code>is_positional: bool</code>  <code>property</code>","text":"<p>If true, this <code>ParamFormat</code> uses positional parameters.</p>"},{"location":"reference/sqly.lib/","title":"sqly.lib","text":""},{"location":"reference/sqly.lib/#sqly.lib.walk","title":"<code>walk(iterator)</code>","text":"<p>Walk a nested iterator and yield items in a single stream.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; l = [1, [2, [3, [4, 5, 6], 7, [8, 9], 10], 11]]\n&gt;&gt;&gt; list(walk(l))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n</code></pre> Source code in <code>sqly/lib.py</code> <pre><code>def walk(iterator):\n\"\"\"\n    Walk a nested iterator and yield items in a single stream.\n    Examples:\n        &gt;&gt;&gt; l = [1, [2, [3, [4, 5, 6], 7, [8, 9], 10], 11]]\n        &gt;&gt;&gt; list(walk(l))\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    \"\"\"\nfor item in iterator:\n# any non-string iterator needs to be recursed into\nif not isinstance(item, str) and hasattr(item, \"__iter__\"):\nfor i in walk(item):\nyield i\nelse:\nyield item\n</code></pre>"},{"location":"reference/sqly.migration/","title":"sqly.migration","text":"<p>Implementation of the sqly migration commands. See the CLI Usage document for more information about usage.</p>"},{"location":"reference/sqly.migration/#sqly.migration.Migration","title":"<code>Migration</code>  <code>dataclass</code>","text":"<p>Represents a single migration.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>The name of the app (module) that owns the Migration.</p> required <code>ts</code> <code>int</code> <p>(<code>YYYYmmddHHMMSSfff</code>) An integer representing the timestamp when the migration was created (millisecond resolution).</p> <code>field(default_factory=migration_timestamp)</code> <code>name</code> <code>str</code> <p>The (optional) name of the migration provides a short description.</p> <code>field(default_factory=str)</code> <code>depends</code> <code>list[str]</code> <p>A list of migrations (keys) that this migration depends on.</p> <code>field(default_factory=list)</code> <code>applied</code> <code>Optional[datetime]</code> <p>If the migration has been applied, the datetime.</p> <code>None</code> <code>doc</code> <code>Optional[str]</code> <p>A document string describing the migration.</p> <code>None</code> <code>up</code> <code>Optional[str]</code> <p>SQL implmenting the \u201cup\u201d or \u201cforward\u201d migration.</p> <code>field(default_factory=list)</code> <code>dn</code> <code>Optional[str]</code> <p>SQL implementing the \u201cdown\u201d or \u201creverse\u201d migration.</p> <code>field(default_factory=list)</code> Source code in <code>sqly/migration.py</code> <pre><code>@dataclass\nclass Migration:\n\"\"\"\n    Represents a single migration.\n    Arguments:\n        app (str): The name of the app (module) that owns the Migration.\n        ts (int): (`YYYYmmddHHMMSSfff`) An integer representing the timestamp when the\n            migration was created (millisecond resolution).\n        name (str): The (optional) name of the migration provides a short description.\n        depends (list[str]): A list of migrations (keys) that this migration depends on.\n        applied (Optional[datetime]): If the migration has been applied, the datetime.\n        doc (Optional[str]): A document string describing the migration.\n        up (Optional[str]): SQL implmenting the \"up\" or \"forward\" migration.\n        dn (Optional[str]): SQL implementing the \"down\" or \"reverse\" migration.\n    \"\"\"\napp: str\nts: int = field(default_factory=migration_timestamp)\nname: str = field(default_factory=str)\ndepends: list[str] = field(default_factory=list)\napplied: Optional[datetime] = None\ndoc: Optional[str] = None\nup: list[str] = field(default_factory=list)\ndn: list[str] = field(default_factory=list)\ndef __post_init__(self):\n# replace non-word characters in the name with an underscore\nself.name = re.sub(r\"[\\W_]+\", \"_\", self.name or \"\")\n# ensure that list attributes are lists (such as when loaded from sqlite3)\nfor key in [\"depends\", \"up\", \"dn\"]:\nif not self.__dict__[key]:\nself.__dict__[key] = []\nelif isinstance(self.__dict__[key], str):\nself.__dict__[key] = json.loads(self.__dict__[key])\nelse:\nself.__dict__[key] = list(self.__dict__[key])\ndef __repr__(self) -&gt; str:\nreturn (\nself.__class__.__name__\n+ \"(\"\n+ \", \".join(\nf\"{key}={getattr(self, key)!r}\" for key in [\"key\", \"depends\", \"applied\"]\n)\n+ \")\"\n)\ndef __str__(self) -&gt; str:\n\"\"\"The string representation of the Migration is the instance as YAML.\"\"\"\nreturn self.yaml()\ndef __hash__(self) -&gt; int:\n\"\"\"The unique hash is based on the Migration.key.\"\"\"\nreturn uuid.uuid3(SQLY_UUID_NAMESPACE, self.key).int\ndef dict(\nself, exclude: Optional[list] = None, exclude_none: bool = False\n) -&gt; Dict[str, Any]:\n\"\"\"\n        The Migration serialized as a dict.\n        Arguments:\n            exclude (Optional[list]): A list of fields to exclude.\n            exclude_none (bool): Whether to exclude fields with value None.\n        \"\"\"\nreturn {\nkey: val\nfor key, val in asdict(self).items()\nif key not in (exclude or []) and (exclude_none is False or val is not None)\n}\n@property\ndef key(self):\n\"\"\"\n        The Migration.key uniquely identifies the migration.\n        Format = `{app}:{ts}_{name}`\n        \"\"\"\nreturn f\"{self.app}:{self.ts}_{self.name}\"\n@property\ndef filename(self):\n\"\"\"The filename (without path) for the Migration\"\"\"\nreturn f\"{self.ts}_{self.name}.yaml\"\n@classmethod\ndef load(cls, filepath: Path) -&gt; Migration:\n\"\"\"\n        Load the migration at the given file path.\n        \"\"\"\nwith open(filepath) as f:\ndata = yaml.safe_load(f.read())\nreturn cls(**data)\n@classmethod\ndef key_load(cls, migration_key: str) -&gt; Migration:\n\"\"\"Load the Migration that has the given key.\"\"\"\nreturn cls.load(cls.key_filepath(migration_key))\n@classmethod\ndef key_filepath(cls, migration_key: str) -&gt; Path:\n\"\"\"The file path of the Migration that has the given key.\n        Arguments:\n            migration_key (str): The Migration key\n        Returns:\n            file path (Path): The files file of the Migration\n        \"\"\"\napp, basename = migration_key.split(\":\")\nreturn app_migrations_path(app) / f\"{basename}.yaml\"\n@classmethod\ndef app_migrations(\ncls, app: str, include_depends: bool = True\n) -&gt; Dict[str, Migration]:\n\"\"\"\n        For a given module name, get the migrations in that module. If `include_depends`\n        is `True` (the default), also include depends migrations from other apps.\n        Arguments:\n            app (str): The name of the app (module) for which to list migrations.\n            include_depends (bool): Whether to include dependency Migrations in the\n                listing.\n        Returns:\n            migrations (dict[str, Migration]): A dict of Migrations, by key.\n        \"\"\"\nmigration_filenames = glob(str(app_migrations_path(app) / \"*.yaml\"))\nmigrations = {\nm.key: m\nfor m in set(cls.load(filename) for filename in migration_filenames)\n}\nif include_depends is True:\ndependencies = {}\nfor migration in migrations.values():\ndependencies |= migration.depends_migrations()\nmigrations |= dependencies\nreturn migrations\n@classmethod\ndef all_migrations(cls, *apps: list[str]) -&gt; Dict[str, Migration]:\n\"\"\"\n        Return all the migrations, including dependencies, for the given app(s).\n        Arguments:\n            apps (list[str]): The app or apps for which to list Migrations.\n        Returns:\n            migrations (dict[str, Migration]): A dict of Migrations, by key.\n        \"\"\"\n# always depend on sqly\nmigrations = cls.app_migrations(\"sqly\")\nfor app in [app for app in apps if app not in [\"sqly\"]]:\nmigrations |= cls.app_migrations(app, include_depends=True)\nreturn migrations\n@classmethod\ndef create(\ncls, app: str, *other_apps: list[str], name: Optional[str] = None\n) -&gt; Migration:\n\"\"\"\n        Create a new Migration object for the given app (module) name. The new Migration\n        is not saved to the filesystem: It is just a Migration instance in memory.\n        Every new migration automatically depends on all the \"leaf\" nodes in the\n        existing migration graph. Leaf nodes are those with out_degree == 0 (no edges\n        pointing out). See:\n        &lt;https://networkx.org/documentation/stable/reference/classes/generated/networkx.DiGraph.out_degree.html&gt;.\n        For a worked example, see:\n        &lt;https://stackoverflow.com/questions/31946253/find-end-nodes-leaf-nodes-in-radial-tree-networkx-graph/31953001&gt;.\n        NOTE: The existing migration graph is calculated from the filesystem, not what\n        is applied in any database. Migrations from other branches might currently be\n        applied in the database; but for the purpose of creating a Migration graph, the\n        filesystem is the source of truth.\n        Arguments:\n            app (str): The name of the app for which to create the new Migration.\n            other_apps (list[str]): The other apps to include in the dependency graph.\n            name (Optional[str]): The name (label) for the migration. Default = `\"\"`.\n        Returns:\n            migration (Migration): The Migration that has just been created.\n        \"\"\"\nmigrations = cls.all_migrations(app, *other_apps)\ngraph = cls.graph(migrations)\ndepends = [node for node in graph.nodes() if graph.out_degree(node) == 0]\nmigration = cls(\napp=app,\nname=name,\ndepends=depends,\n)\nreturn migration\n@classmethod\ndef database_migrations(\ncls, connection: Any, dialect: Dialect\n) -&gt; Dict[str, Migration]:\n\"\"\"\n        Query the database with the given `connection` and return a dict of the\n        Migrations in the database, by key. If no Migrations have been applied in the\n        database, the result is an empty dict.\n        Arguments:\n            connection (Any): A database connection.\n        Returns:\n            migrations (dict[str, Migration]): A dict of Migrations by key.\n        \"\"\"\nsql = SQL(dialect=dialect)\ntry:\nresults = sql.select(connection, \"select * from sqly_migrations\")\nrecords = list(results)\nexcept Exception as exc:\nprint(str(exc))\nrecords = []\nreturn {m.key: m for m in set(cls(**record) for record in records)}\n@classmethod\ndef migrate(\ncls,\nconnection: Any,\ndialect: Dialect,\nmigration: Migration,\ndryrun: bool = False,\n):\n\"\"\"\n        Migrate the database to this migration, either up or down, using the given\n        database connection.\n        Algorithm:\n        1. Collate the list of applied migrations in the database with the list of\n           migrations available in this application.\n        2. Calculate the graph path to reach this migration and whether this is an \"up\"\n           or \"down\" migration.\n            - if this migration has not been applied to the database, then the graph\n              path is from the last applied predecessor \"up\" to this migration.\n            - if this migration has been applied to the database, then the graph path is\n              from the last applied successor \"down\" to this migration.\n        3. Apply the sequence of migrations (either up or down).\n        [_What about situations in which the path to the given Migration includes both\n        \"down\" Migrations to back out of another branch and \"up\" Migrations preceding\n        the given Migration on its branch? Our current solution is to ignore \"other\"\n        branches and only migrate from the last applied predecessor._]\n        Arguments:\n            connection (Any): A database connection. dialect (Dialect): The SQL database\n            migration (Migration): The Migration that we are migrating _to_.\n            dryrun (bool): Whether this is a dry run.\n        \"\"\"\ndb_migrations = cls.database_migrations(connection, dialect)\nmigrations = db_migrations | cls.all_migrations(migration.app)\ngraph = cls.graph(migrations)\nif migration.key not in db_migrations:\n# apply 'up' migrations for all ancestors and this migration\nsubgraph = nx.subgraph(graph, migration.ancestors(graph) | {migration.key})\nfor key in nx.lexicographical_topological_sort(subgraph):\nif key not in db_migrations:\nmigrations[key].apply(\nconnection, dialect, direction=\"up\", dryrun=dryrun\n)\nelse:\n# apply 'dn' migrations for all descendants in reverse\nsubgraph = nx.subgraph(graph, migration.descendants(graph))\nfor key in reversed(list(nx.lexicographical_topological_sort(subgraph))):\nif key in db_migrations:\nmigrations[key].apply(\nconnection, dialect, direction=\"dn\", dryrun=dryrun\n)\ndef depends_migrations(self) -&gt; Dict[str, Migration]:\n\"\"\"\n        All migrations that this migration depends on, recursively.\n        Returns:\n            migrations (dict[str, Migration]): A dict of Migrations by key.\n        \"\"\"\ndependencies = {}\nfor depend in self.depends:\nmigration = self.key_load(depend)\ndependencies |= {depend: migration} | migration.depends_migrations()\nreturn dependencies\n@classmethod\ndef graph(cls, migrations: Mapping[str, Migration]) -&gt; nx.classes.digraph.DiGraph:\n\"\"\"\n        Given a mapping of Migrations, create a dependency graph of Migrations. The\n        resulting graph is a DAG (directed acyclic graph) that is a [transitive\n        reduction](https://en.wikipedia.org/wiki/Transitive_reduction) of the Migrations\n        graph. If the graph is not a DAG (e.g., it has cycles) then a networkx.HasACycle\n        exception is raised.\n        Arguments:\n            migrations (Mapping[str, Migration]): A mapping of Migrations by key.\n        Returns:\n            graph (nx.classes.digraph.DiGraph): A networkx DiGraph of the Migrations.\n        \"\"\"\ngraph = nx.DiGraph()\ndag = {key: migrations[key].depends for key in migrations}\nfor migration_key, migration_depends in dag.items():\ngraph.add_node(migration_key)\nfor depend in migration_depends:\ngraph.add_edge(depend, migration_key)\nif not nx.is_directed_acyclic_graph(graph):\nraise nx.HasACycle(dag)\nreturn nx.transitive_reduction(graph)\ndef ancestors(self, graph: nx.classes.digraph.DiGraph) -&gt; AbstractSet[str]:\n\"\"\"\n        Given a Migration and a graph, return the set of all ancestors of this\n        Migration. If this Migration is not in the given graph, a NetworkXError\n        Exception is raised.\n        Arguments:\n            graph (nx.classes.digraph.DiGraph): A graph of Migrations including this\n                one.\n        Returns:\n            migration keys (set): The set of migrations (keys) that are ancestors.\n        \"\"\"\nreturn nx.ancestors(graph, self.key)\ndef descendants(self, graph: nx.classes.digraph.DiGraph) -&gt; AbstractSet[str]:\n\"\"\"\n        Given a Migration and a graph, return the set of all descendants of this\n        Migration. If this Migration is not in the given graph, a NetworkXError\n        Exception is raised.\n        Arguments:\n            graph (nx.classes.digraph.DiGraph): A graph of Migrations including this\n                one.\n        Returns:\n            migration keys (set): The set of migrations (keys) that are ancestors.\n        \"\"\"\nreturn nx.descendants(graph, self.key)\ndef yaml(self, exclude: Optional[list] = None, exclude_none: bool = False) -&gt; str:\n\"\"\"\n        Serialize this Migration as a YAML string.\n        Arguments:\n            exclude (Optional[list]): A list of fields to exclude.\n            exclude_none (bool): Whether to exclude fields with value None.\n        \"\"\"\nreturn yaml.dump(\nself.dict(exclude=exclude, exclude_none=exclude_none),\ndefault_flow_style=False,\nsort_keys=False,\n)\ndef save(self, exclude: Optional[list] = None, exclude_none: bool = False):\n\"\"\"\n        Save this Migration to the filesystem.\n        Arguments:\n            exclude (Optional[list]): A list of fields to exclude.\n            exclude_none (bool): Whether to exclude fields with value None.\n        Returns:\n            tuple (filepath, size): The filepath where the Migration was saved, and its\n                size in bytes.\n        \"\"\"\nfilepath = app_migrations_path(self.app) / self.filename\nos.makedirs(filepath.parent, exist_ok=True)\nwith open(filepath, \"wb\") as f:\nsize = f.write(\nself.yaml(exclude=exclude, exclude_none=exclude_none).encode()\n)\nreturn filepath, size\ndef apply(\nself,\nconnection: Any,\ndialect: Dialect,\ndirection: str = \"up\",\ndryrun: bool = False,\n):\n\"\"\"\n        Apply the migration (direction = 'up' or 'dn') to connection database. The\n        entire migration script is wrapped in a transaction. (This method is called\n        internally by `Migration.migrate()`).\n        Arguments:\n            connection (Any): A database connection.\n            dialect (Dialect): The SQL dialect of the database connection.\n            direction (str): Which migration to apply: \"up\" or \"dn\".\n            dryrun (bool): Whether this is a dry run.\n        \"\"\"\nprint(self.key, direction, end=\" ... \")\nif dryrun:\nprint(\"DRY RUN\")\nreturn\nmigration_queries = getattr(self, direction)\nif migration_queries:\nfor migration_query in migration_queries:\nconnection.execute(migration_query)\nif direction == \"up\":\nsqly_migrations_query = self.insert_query(dialect)\nelse:\nsqly_migrations_query = self.delete_query(dialect)\nconnection.execute(*sqly_migrations_query)\nconnection.commit()\nprint(\"OK\")\ndef insert_query(self, dialect: Dialect) -&gt; Any:\n\"\"\"\n        Render a SQL query to insert this Migration into the sqly_migrations table.\n        Arguments:\n            dialect (Dialect): The SQL database dialect to render the query for.\n        Returns:\n            tuple (str, params...): The SQL query and params formatted for the database\n                dialect.\n        \"\"\"\ndata = {k: v for k, v in self.dict(exclude_none=True).items()}\ndata[\"depends\"] = json.dumps(data.get(\"depends\") or [])\ndata[\"up\"] = json.dumps(data.get(\"up\") or [])\ndata[\"dn\"] = json.dumps(data.get(\"dn\") or [])\nsql = queries.INSERT(\"sqly_migrations\", data)\nreturn SQL(dialect=dialect).render(sql, data)\ndef delete_query(self, dialect):\n\"\"\"\n        Render a SQL query to delete this Migration from the sqly_migrations table.\n        Arguments:\n            dialect (Dialect): The SQL database dialect to render the query for.\n        Returns:\n            tuple (str, params...): The SQL query and params formatted for the database\n                dialect.\n        \"\"\"\nsql = queries.DELETE(\n\"sqly_migrations\", [Q.filter(key) for key in [\"app\", \"ts\", \"name\"]]\n)\nreturn SQL(dialect=dialect).render(sql, self.dict())\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.filename","title":"<code>filename</code>  <code>property</code>","text":"<p>The filename (without path) for the Migration</p>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.key","title":"<code>key</code>  <code>property</code>","text":"<p>The Migration.key uniquely identifies the migration. Format = <code>{app}:{ts}_{name}</code></p>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.__hash__","title":"<code>__hash__()</code>","text":"<p>The unique hash is based on the Migration.key.</p> Source code in <code>sqly/migration.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"The unique hash is based on the Migration.key.\"\"\"\nreturn uuid.uuid3(SQLY_UUID_NAMESPACE, self.key).int\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.__str__","title":"<code>__str__()</code>","text":"<p>The string representation of the Migration is the instance as YAML.</p> Source code in <code>sqly/migration.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"The string representation of the Migration is the instance as YAML.\"\"\"\nreturn self.yaml()\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.all_migrations","title":"<code>all_migrations(*apps)</code>  <code>classmethod</code>","text":"<p>Return all the migrations, including dependencies, for the given app(s).</p> <p>Parameters:</p> Name Type Description Default <code>apps</code> <code>list[str]</code> <p>The app or apps for which to list Migrations.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>migrations</code> <code>dict[str, Migration]</code> <p>A dict of Migrations, by key.</p> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef all_migrations(cls, *apps: list[str]) -&gt; Dict[str, Migration]:\n\"\"\"\n    Return all the migrations, including dependencies, for the given app(s).\n    Arguments:\n        apps (list[str]): The app or apps for which to list Migrations.\n    Returns:\n        migrations (dict[str, Migration]): A dict of Migrations, by key.\n    \"\"\"\n# always depend on sqly\nmigrations = cls.app_migrations(\"sqly\")\nfor app in [app for app in apps if app not in [\"sqly\"]]:\nmigrations |= cls.app_migrations(app, include_depends=True)\nreturn migrations\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.ancestors","title":"<code>ancestors(graph)</code>","text":"<p>Given a Migration and a graph, return the set of all ancestors of this Migration. If this Migration is not in the given graph, a NetworkXError Exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>nx.classes.digraph.DiGraph</code> <p>A graph of Migrations including this one.</p> required <p>Returns:</p> Type Description <code>AbstractSet[str]</code> <p>migration keys (set): The set of migrations (keys) that are ancestors.</p> Source code in <code>sqly/migration.py</code> <pre><code>def ancestors(self, graph: nx.classes.digraph.DiGraph) -&gt; AbstractSet[str]:\n\"\"\"\n    Given a Migration and a graph, return the set of all ancestors of this\n    Migration. If this Migration is not in the given graph, a NetworkXError\n    Exception is raised.\n    Arguments:\n        graph (nx.classes.digraph.DiGraph): A graph of Migrations including this\n            one.\n    Returns:\n        migration keys (set): The set of migrations (keys) that are ancestors.\n    \"\"\"\nreturn nx.ancestors(graph, self.key)\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.app_migrations","title":"<code>app_migrations(app, include_depends=True)</code>  <code>classmethod</code>","text":"<p>For a given module name, get the migrations in that module. If <code>include_depends</code> is <code>True</code> (the default), also include depends migrations from other apps.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>The name of the app (module) for which to list migrations.</p> required <code>include_depends</code> <code>bool</code> <p>Whether to include dependency Migrations in the listing.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>migrations</code> <code>dict[str, Migration]</code> <p>A dict of Migrations, by key.</p> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef app_migrations(\ncls, app: str, include_depends: bool = True\n) -&gt; Dict[str, Migration]:\n\"\"\"\n    For a given module name, get the migrations in that module. If `include_depends`\n    is `True` (the default), also include depends migrations from other apps.\n    Arguments:\n        app (str): The name of the app (module) for which to list migrations.\n        include_depends (bool): Whether to include dependency Migrations in the\n            listing.\n    Returns:\n        migrations (dict[str, Migration]): A dict of Migrations, by key.\n    \"\"\"\nmigration_filenames = glob(str(app_migrations_path(app) / \"*.yaml\"))\nmigrations = {\nm.key: m\nfor m in set(cls.load(filename) for filename in migration_filenames)\n}\nif include_depends is True:\ndependencies = {}\nfor migration in migrations.values():\ndependencies |= migration.depends_migrations()\nmigrations |= dependencies\nreturn migrations\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.apply","title":"<code>apply(connection, dialect, direction='up', dryrun=False)</code>","text":"<p>Apply the migration (direction = \u2018up\u2019 or \u2018dn\u2019) to connection database. The entire migration script is wrapped in a transaction. (This method is called internally by <code>Migration.migrate()</code>).</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Any</code> <p>A database connection.</p> required <code>dialect</code> <code>Dialect</code> <p>The SQL dialect of the database connection.</p> required <code>direction</code> <code>str</code> <p>Which migration to apply: \u201cup\u201d or \u201cdn\u201d.</p> <code>'up'</code> <code>dryrun</code> <code>bool</code> <p>Whether this is a dry run.</p> <code>False</code> Source code in <code>sqly/migration.py</code> <pre><code>def apply(\nself,\nconnection: Any,\ndialect: Dialect,\ndirection: str = \"up\",\ndryrun: bool = False,\n):\n\"\"\"\n    Apply the migration (direction = 'up' or 'dn') to connection database. The\n    entire migration script is wrapped in a transaction. (This method is called\n    internally by `Migration.migrate()`).\n    Arguments:\n        connection (Any): A database connection.\n        dialect (Dialect): The SQL dialect of the database connection.\n        direction (str): Which migration to apply: \"up\" or \"dn\".\n        dryrun (bool): Whether this is a dry run.\n    \"\"\"\nprint(self.key, direction, end=\" ... \")\nif dryrun:\nprint(\"DRY RUN\")\nreturn\nmigration_queries = getattr(self, direction)\nif migration_queries:\nfor migration_query in migration_queries:\nconnection.execute(migration_query)\nif direction == \"up\":\nsqly_migrations_query = self.insert_query(dialect)\nelse:\nsqly_migrations_query = self.delete_query(dialect)\nconnection.execute(*sqly_migrations_query)\nconnection.commit()\nprint(\"OK\")\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.create","title":"<code>create(app, *other_apps, name=None)</code>  <code>classmethod</code>","text":"<p>Create a new Migration object for the given app (module) name. The new Migration is not saved to the filesystem: It is just a Migration instance in memory.</p> <p>Every new migration automatically depends on all the \u201cleaf\u201d nodes in the existing migration graph. Leaf nodes are those with out_degree == 0 (no edges pointing out). See: https://networkx.org/documentation/stable/reference/classes/generated/networkx.DiGraph.out_degree.html. For a worked example, see: https://stackoverflow.com/questions/31946253/find-end-nodes-leaf-nodes-in-radial-tree-networkx-graph/31953001.</p> <p>NOTE: The existing migration graph is calculated from the filesystem, not what is applied in any database. Migrations from other branches might currently be applied in the database; but for the purpose of creating a Migration graph, the filesystem is the source of truth.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>The name of the app for which to create the new Migration.</p> required <code>other_apps</code> <code>list[str]</code> <p>The other apps to include in the dependency graph.</p> <code>()</code> <code>name</code> <code>Optional[str]</code> <p>The name (label) for the migration. Default = <code>\"\"</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>migration</code> <code>Migration</code> <p>The Migration that has just been created.</p> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef create(\ncls, app: str, *other_apps: list[str], name: Optional[str] = None\n) -&gt; Migration:\n\"\"\"\n    Create a new Migration object for the given app (module) name. The new Migration\n    is not saved to the filesystem: It is just a Migration instance in memory.\n    Every new migration automatically depends on all the \"leaf\" nodes in the\n    existing migration graph. Leaf nodes are those with out_degree == 0 (no edges\n    pointing out). See:\n    &lt;https://networkx.org/documentation/stable/reference/classes/generated/networkx.DiGraph.out_degree.html&gt;.\n    For a worked example, see:\n    &lt;https://stackoverflow.com/questions/31946253/find-end-nodes-leaf-nodes-in-radial-tree-networkx-graph/31953001&gt;.\n    NOTE: The existing migration graph is calculated from the filesystem, not what\n    is applied in any database. Migrations from other branches might currently be\n    applied in the database; but for the purpose of creating a Migration graph, the\n    filesystem is the source of truth.\n    Arguments:\n        app (str): The name of the app for which to create the new Migration.\n        other_apps (list[str]): The other apps to include in the dependency graph.\n        name (Optional[str]): The name (label) for the migration. Default = `\"\"`.\n    Returns:\n        migration (Migration): The Migration that has just been created.\n    \"\"\"\nmigrations = cls.all_migrations(app, *other_apps)\ngraph = cls.graph(migrations)\ndepends = [node for node in graph.nodes() if graph.out_degree(node) == 0]\nmigration = cls(\napp=app,\nname=name,\ndepends=depends,\n)\nreturn migration\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.database_migrations","title":"<code>database_migrations(connection, dialect)</code>  <code>classmethod</code>","text":"<p>Query the database with the given <code>connection</code> and return a dict of the Migrations in the database, by key. If no Migrations have been applied in the database, the result is an empty dict.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Any</code> <p>A database connection.</p> required <p>Returns:</p> Name Type Description <code>migrations</code> <code>dict[str, Migration]</code> <p>A dict of Migrations by key.</p> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef database_migrations(\ncls, connection: Any, dialect: Dialect\n) -&gt; Dict[str, Migration]:\n\"\"\"\n    Query the database with the given `connection` and return a dict of the\n    Migrations in the database, by key. If no Migrations have been applied in the\n    database, the result is an empty dict.\n    Arguments:\n        connection (Any): A database connection.\n    Returns:\n        migrations (dict[str, Migration]): A dict of Migrations by key.\n    \"\"\"\nsql = SQL(dialect=dialect)\ntry:\nresults = sql.select(connection, \"select * from sqly_migrations\")\nrecords = list(results)\nexcept Exception as exc:\nprint(str(exc))\nrecords = []\nreturn {m.key: m for m in set(cls(**record) for record in records)}\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.delete_query","title":"<code>delete_query(dialect)</code>","text":"<p>Render a SQL query to delete this Migration from the sqly_migrations table.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Dialect</code> <p>The SQL database dialect to render the query for.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>str, params...</code> <p>The SQL query and params formatted for the database dialect.</p> Source code in <code>sqly/migration.py</code> <pre><code>def delete_query(self, dialect):\n\"\"\"\n    Render a SQL query to delete this Migration from the sqly_migrations table.\n    Arguments:\n        dialect (Dialect): The SQL database dialect to render the query for.\n    Returns:\n        tuple (str, params...): The SQL query and params formatted for the database\n            dialect.\n    \"\"\"\nsql = queries.DELETE(\n\"sqly_migrations\", [Q.filter(key) for key in [\"app\", \"ts\", \"name\"]]\n)\nreturn SQL(dialect=dialect).render(sql, self.dict())\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.depends_migrations","title":"<code>depends_migrations()</code>","text":"<p>All migrations that this migration depends on, recursively.</p> <p>Returns:</p> Name Type Description <code>migrations</code> <code>dict[str, Migration]</code> <p>A dict of Migrations by key.</p> Source code in <code>sqly/migration.py</code> <pre><code>def depends_migrations(self) -&gt; Dict[str, Migration]:\n\"\"\"\n    All migrations that this migration depends on, recursively.\n    Returns:\n        migrations (dict[str, Migration]): A dict of Migrations by key.\n    \"\"\"\ndependencies = {}\nfor depend in self.depends:\nmigration = self.key_load(depend)\ndependencies |= {depend: migration} | migration.depends_migrations()\nreturn dependencies\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.descendants","title":"<code>descendants(graph)</code>","text":"<p>Given a Migration and a graph, return the set of all descendants of this Migration. If this Migration is not in the given graph, a NetworkXError Exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>nx.classes.digraph.DiGraph</code> <p>A graph of Migrations including this one.</p> required <p>Returns:</p> Type Description <code>AbstractSet[str]</code> <p>migration keys (set): The set of migrations (keys) that are ancestors.</p> Source code in <code>sqly/migration.py</code> <pre><code>def descendants(self, graph: nx.classes.digraph.DiGraph) -&gt; AbstractSet[str]:\n\"\"\"\n    Given a Migration and a graph, return the set of all descendants of this\n    Migration. If this Migration is not in the given graph, a NetworkXError\n    Exception is raised.\n    Arguments:\n        graph (nx.classes.digraph.DiGraph): A graph of Migrations including this\n            one.\n    Returns:\n        migration keys (set): The set of migrations (keys) that are ancestors.\n    \"\"\"\nreturn nx.descendants(graph, self.key)\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.dict","title":"<code>dict(exclude=None, exclude_none=False)</code>","text":"<p>The Migration serialized as a dict.</p> <p>Parameters:</p> Name Type Description Default <code>exclude</code> <code>Optional[list]</code> <p>A list of fields to exclude.</p> <code>None</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields with value None.</p> <code>False</code> Source code in <code>sqly/migration.py</code> <pre><code>def dict(\nself, exclude: Optional[list] = None, exclude_none: bool = False\n) -&gt; Dict[str, Any]:\n\"\"\"\n    The Migration serialized as a dict.\n    Arguments:\n        exclude (Optional[list]): A list of fields to exclude.\n        exclude_none (bool): Whether to exclude fields with value None.\n    \"\"\"\nreturn {\nkey: val\nfor key, val in asdict(self).items()\nif key not in (exclude or []) and (exclude_none is False or val is not None)\n}\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.graph","title":"<code>graph(migrations)</code>  <code>classmethod</code>","text":"<p>Given a mapping of Migrations, create a dependency graph of Migrations. The resulting graph is a DAG (directed acyclic graph) that is a transitive reduction of the Migrations graph. If the graph is not a DAG (e.g., it has cycles) then a networkx.HasACycle exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>migrations</code> <code>Mapping[str, Migration]</code> <p>A mapping of Migrations by key.</p> required <p>Returns:</p> Name Type Description <code>graph</code> <code>nx.classes.digraph.DiGraph</code> <p>A networkx DiGraph of the Migrations.</p> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef graph(cls, migrations: Mapping[str, Migration]) -&gt; nx.classes.digraph.DiGraph:\n\"\"\"\n    Given a mapping of Migrations, create a dependency graph of Migrations. The\n    resulting graph is a DAG (directed acyclic graph) that is a [transitive\n    reduction](https://en.wikipedia.org/wiki/Transitive_reduction) of the Migrations\n    graph. If the graph is not a DAG (e.g., it has cycles) then a networkx.HasACycle\n    exception is raised.\n    Arguments:\n        migrations (Mapping[str, Migration]): A mapping of Migrations by key.\n    Returns:\n        graph (nx.classes.digraph.DiGraph): A networkx DiGraph of the Migrations.\n    \"\"\"\ngraph = nx.DiGraph()\ndag = {key: migrations[key].depends for key in migrations}\nfor migration_key, migration_depends in dag.items():\ngraph.add_node(migration_key)\nfor depend in migration_depends:\ngraph.add_edge(depend, migration_key)\nif not nx.is_directed_acyclic_graph(graph):\nraise nx.HasACycle(dag)\nreturn nx.transitive_reduction(graph)\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.insert_query","title":"<code>insert_query(dialect)</code>","text":"<p>Render a SQL query to insert this Migration into the sqly_migrations table.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Dialect</code> <p>The SQL database dialect to render the query for.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>str, params...</code> <p>The SQL query and params formatted for the database dialect.</p> Source code in <code>sqly/migration.py</code> <pre><code>def insert_query(self, dialect: Dialect) -&gt; Any:\n\"\"\"\n    Render a SQL query to insert this Migration into the sqly_migrations table.\n    Arguments:\n        dialect (Dialect): The SQL database dialect to render the query for.\n    Returns:\n        tuple (str, params...): The SQL query and params formatted for the database\n            dialect.\n    \"\"\"\ndata = {k: v for k, v in self.dict(exclude_none=True).items()}\ndata[\"depends\"] = json.dumps(data.get(\"depends\") or [])\ndata[\"up\"] = json.dumps(data.get(\"up\") or [])\ndata[\"dn\"] = json.dumps(data.get(\"dn\") or [])\nsql = queries.INSERT(\"sqly_migrations\", data)\nreturn SQL(dialect=dialect).render(sql, data)\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.key_filepath","title":"<code>key_filepath(migration_key)</code>  <code>classmethod</code>","text":"<p>The file path of the Migration that has the given key.</p> <p>Parameters:</p> Name Type Description Default <code>migration_key</code> <code>str</code> <p>The Migration key</p> required <p>Returns:</p> Type Description <code>Path</code> <p>file path (Path): The files file of the Migration</p> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef key_filepath(cls, migration_key: str) -&gt; Path:\n\"\"\"The file path of the Migration that has the given key.\n    Arguments:\n        migration_key (str): The Migration key\n    Returns:\n        file path (Path): The files file of the Migration\n    \"\"\"\napp, basename = migration_key.split(\":\")\nreturn app_migrations_path(app) / f\"{basename}.yaml\"\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.key_load","title":"<code>key_load(migration_key)</code>  <code>classmethod</code>","text":"<p>Load the Migration that has the given key.</p> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef key_load(cls, migration_key: str) -&gt; Migration:\n\"\"\"Load the Migration that has the given key.\"\"\"\nreturn cls.load(cls.key_filepath(migration_key))\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.load","title":"<code>load(filepath)</code>  <code>classmethod</code>","text":"<p>Load the migration at the given file path.</p> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef load(cls, filepath: Path) -&gt; Migration:\n\"\"\"\n    Load the migration at the given file path.\n    \"\"\"\nwith open(filepath) as f:\ndata = yaml.safe_load(f.read())\nreturn cls(**data)\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.migrate","title":"<code>migrate(connection, dialect, migration, dryrun=False)</code>  <code>classmethod</code>","text":"<p>Migrate the database to this migration, either up or down, using the given database connection.</p> <p>Algorithm:</p> <ol> <li> <p>Collate the list of applied migrations in the database with the list of    migrations available in this application.</p> </li> <li> <p>Calculate the graph path to reach this migration and whether this is an \u201cup\u201d    or \u201cdown\u201d migration.</p> <ul> <li>if this migration has not been applied to the database, then the graph   path is from the last applied predecessor \u201cup\u201d to this migration.</li> <li>if this migration has been applied to the database, then the graph path is   from the last applied successor \u201cdown\u201d to this migration.</li> </ul> </li> <li> <p>Apply the sequence of migrations (either up or down).</p> </li> </ol> <p>[What about situations in which the path to the given Migration includes both \u201cdown\u201d Migrations to back out of another branch and \u201cup\u201d Migrations preceding the given Migration on its branch? Our current solution is to ignore \u201cother\u201d branches and only migrate from the last applied predecessor.]</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Any</code> <p>A database connection. dialect (Dialect): The SQL database</p> required <code>migration</code> <code>Migration</code> <p>The Migration that we are migrating to.</p> required <code>dryrun</code> <code>bool</code> <p>Whether this is a dry run.</p> <code>False</code> Source code in <code>sqly/migration.py</code> <pre><code>@classmethod\ndef migrate(\ncls,\nconnection: Any,\ndialect: Dialect,\nmigration: Migration,\ndryrun: bool = False,\n):\n\"\"\"\n    Migrate the database to this migration, either up or down, using the given\n    database connection.\n    Algorithm:\n    1. Collate the list of applied migrations in the database with the list of\n       migrations available in this application.\n    2. Calculate the graph path to reach this migration and whether this is an \"up\"\n       or \"down\" migration.\n        - if this migration has not been applied to the database, then the graph\n          path is from the last applied predecessor \"up\" to this migration.\n        - if this migration has been applied to the database, then the graph path is\n          from the last applied successor \"down\" to this migration.\n    3. Apply the sequence of migrations (either up or down).\n    [_What about situations in which the path to the given Migration includes both\n    \"down\" Migrations to back out of another branch and \"up\" Migrations preceding\n    the given Migration on its branch? Our current solution is to ignore \"other\"\n    branches and only migrate from the last applied predecessor._]\n    Arguments:\n        connection (Any): A database connection. dialect (Dialect): The SQL database\n        migration (Migration): The Migration that we are migrating _to_.\n        dryrun (bool): Whether this is a dry run.\n    \"\"\"\ndb_migrations = cls.database_migrations(connection, dialect)\nmigrations = db_migrations | cls.all_migrations(migration.app)\ngraph = cls.graph(migrations)\nif migration.key not in db_migrations:\n# apply 'up' migrations for all ancestors and this migration\nsubgraph = nx.subgraph(graph, migration.ancestors(graph) | {migration.key})\nfor key in nx.lexicographical_topological_sort(subgraph):\nif key not in db_migrations:\nmigrations[key].apply(\nconnection, dialect, direction=\"up\", dryrun=dryrun\n)\nelse:\n# apply 'dn' migrations for all descendants in reverse\nsubgraph = nx.subgraph(graph, migration.descendants(graph))\nfor key in reversed(list(nx.lexicographical_topological_sort(subgraph))):\nif key in db_migrations:\nmigrations[key].apply(\nconnection, dialect, direction=\"dn\", dryrun=dryrun\n)\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.save","title":"<code>save(exclude=None, exclude_none=False)</code>","text":"<p>Save this Migration to the filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>exclude</code> <code>Optional[list]</code> <p>A list of fields to exclude.</p> <code>None</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields with value None.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>(filepath, size)</code> <p>The filepath where the Migration was saved, and its size in bytes.</p> Source code in <code>sqly/migration.py</code> <pre><code>def save(self, exclude: Optional[list] = None, exclude_none: bool = False):\n\"\"\"\n    Save this Migration to the filesystem.\n    Arguments:\n        exclude (Optional[list]): A list of fields to exclude.\n        exclude_none (bool): Whether to exclude fields with value None.\n    Returns:\n        tuple (filepath, size): The filepath where the Migration was saved, and its\n            size in bytes.\n    \"\"\"\nfilepath = app_migrations_path(self.app) / self.filename\nos.makedirs(filepath.parent, exist_ok=True)\nwith open(filepath, \"wb\") as f:\nsize = f.write(\nself.yaml(exclude=exclude, exclude_none=exclude_none).encode()\n)\nreturn filepath, size\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.Migration.yaml","title":"<code>yaml(exclude=None, exclude_none=False)</code>","text":"<p>Serialize this Migration as a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>exclude</code> <code>Optional[list]</code> <p>A list of fields to exclude.</p> <code>None</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields with value None.</p> <code>False</code> Source code in <code>sqly/migration.py</code> <pre><code>def yaml(self, exclude: Optional[list] = None, exclude_none: bool = False) -&gt; str:\n\"\"\"\n    Serialize this Migration as a YAML string.\n    Arguments:\n        exclude (Optional[list]): A list of fields to exclude.\n        exclude_none (bool): Whether to exclude fields with value None.\n    \"\"\"\nreturn yaml.dump(\nself.dict(exclude=exclude, exclude_none=exclude_none),\ndefault_flow_style=False,\nsort_keys=False,\n)\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.app_migrations_path","title":"<code>app_migrations_path(app)</code>","text":"<p>For a given app name, get the path to its migrations directory.</p> Source code in <code>sqly/migration.py</code> <pre><code>def app_migrations_path(app):\n\"\"\"\n    For a given app name, get the path to its migrations directory.\n    \"\"\"\nmod = import_module(app)\nmod_filepath = Path(next(iter(mod.__path__)))\nreturn mod_filepath / \"migrations\"\n</code></pre>"},{"location":"reference/sqly.migration/#sqly.migration.migration_timestamp","title":"<code>migration_timestamp()</code>","text":"<p>Return an integer with the UTC timestamp to millisecond resolution (17 digits =&gt; bigint)</p> Source code in <code>sqly/migration.py</code> <pre><code>def migration_timestamp():\n\"\"\"\n    Return an integer with the UTC timestamp to millisecond resolution (17 digits =&gt; bigint)\n    \"\"\"\nreturn int(datetime.now(tz=timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")[:-3])\n</code></pre>"},{"location":"reference/sqly.queries/","title":"sqly.queries","text":"<p>A set of basic CRUD queries that make it easier to get started using SQLY and also provide basic examples of using the library to construct queries.</p> <p>The names of these queries are all caps (SELECT, etc.) to remind users that we are just constructing SQL strings representing queries of the same names - SELECT, etc. are capitalized in SQL. It also helps them to stand out in code, making it a little easier to audit where in the codebase queries are being constructed.</p>"},{"location":"reference/sqly.queries/#sqly.queries.DELETE","title":"<code>DELETE(relation, filters)</code>","text":"<p>Build a DELETE query with the following form: <pre><code>DELETE FROM relation\nWHERE (filters)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>str</code> <p>The name of the table to DELETE FROM.</p> required <code>filters</code> <code>Iterable</code> <p>An iterable of strings represent WHERE filters. At least one filter is required.</p> required <p>Returns:</p> Name Type Description <code>sql</code> <code>str</code> <p>The string representing the SELECT query.</p> Source code in <code>sqly/queries.py</code> <pre><code>def DELETE(relation: str, filters: Iterable[str]) -&gt; str:\n\"\"\"\n    Build a DELETE query with the following form:\n    ```sql\n    DELETE FROM relation\n    WHERE (filters)\n    ```\n    Arguments:\n        relation (str): The name of the table to DELETE FROM.\n        filters (Iterable): An iterable of strings represent WHERE filters. At least one\n            filter is required.\n    Returns:\n        sql (str): The string representing the SELECT query.\n    \"\"\"\nquery = [\nf\"DELETE FROM {relation}\",\nf\"WHERE {' AND '.join(filters)}\",\n]\nreturn \" \".join(query)\n</code></pre>"},{"location":"reference/sqly.queries/#sqly.queries.INSERT","title":"<code>INSERT(relation, data)</code>","text":"<p>Build an INSERT query with the following form: <pre><code>INSERT INTO relation (fields(data))\nVALUES (params(data))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>str</code> <p>The name of the table to INSERT INTO.</p> required <code>data</code> <code>Iterable</code> <p>An iterable representing field names to insert.</p> required <p>Returns:</p> Name Type Description <code>sql</code> <code>str</code> <p>The string representing the INSERT query.</p> Source code in <code>sqly/queries.py</code> <pre><code>def INSERT(relation: str, data: Iterable) -&gt; str:\n\"\"\"\n    Build an INSERT query with the following form:\n    ```sql\n    INSERT INTO relation (fields(data))\n    VALUES (params(data))\n    ```\n    Arguments:\n        relation (str): The name of the table to INSERT INTO.\n        data (Iterable): An iterable representing field names to insert.\n    Returns:\n        sql (str): The string representing the INSERT query.\n    \"\"\"\nquery = [\nf\"INSERT INTO {relation}\",\nf\"({Q.fields(data)})\",\nf\"VALUES ({Q.params(data)})\",\n]\nreturn \" \".join(query)\n</code></pre>"},{"location":"reference/sqly.queries/#sqly.queries.SELECT","title":"<code>SELECT(relation, fields=None, filters=None, orderby=None, limit=None, offset=None)</code>","text":"<p>Build a SELECT query with the following form: <pre><code>SELECT fields FROM relation\n[WHERE filters]\n[ORDER BY orderby]\n[LIMIT limit]\n[OFFSET offset]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>str</code> <p>The name of the table or view from which to SELECT.</p> required <code>fields</code> <code>Iterable[str]</code> <p>An iterable of field names to include in the SELECT.</p> <code>None</code> <code>filters</code> <code>Iterable[str]</code> <p>An iterable of WHERE filters to apply.</p> <code>None</code> <code>orderby</code> <code>str</code> <p>A string representing which fields to ORDER BY.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The LIMIT on the maximum number of records to SELECT.</p> <code>None</code> <code>offset</code> <code>int</code> <p>The OFFSET to apply to the SELECT.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sql</code> <code>str</code> <p>The string representing the SELECT query.</p> Source code in <code>sqly/queries.py</code> <pre><code>def SELECT(\nrelation: str,\nfields: Optional[Iterable] = None,\nfilters: Optional[list[str]] = None,\norderby: Optional[str] = None,\nlimit: Optional[int] = None,\noffset: Optional[int] = None,\n) -&gt; str:\n\"\"\"\n    Build a SELECT query with the following form:\n    ```sql\n    SELECT fields FROM relation\n        [WHERE filters]\n        [ORDER BY orderby]\n        [LIMIT limit]\n        [OFFSET offset]\n    ```\n    Arguments:\n        relation (str): The name of the table or view from which to SELECT.\n        fields (Iterable[str]): An iterable of field names to include in the SELECT.\n        filters (Iterable[str]): An iterable of WHERE filters to apply.\n        orderby (str): A string representing which fields to ORDER BY.\n        limit (int): The LIMIT on the maximum number of records to SELECT.\n        offset (int): The OFFSET to apply to the SELECT.\n    Returns:\n        sql (str): The string representing the SELECT query.\n    \"\"\"\nfields = fields or [\"*\"]\nquery = [\nf\"SELECT {Q.fields(fields)}\",\nf\"FROM {relation}\",\n]\nif filters:\nquery.append(f\"WHERE {' AND '.join(filters)}\")\nif orderby:\nquery.append(f\"ORDER BY {orderby}\")\nif limit:\nquery.append(f\"LIMIT {limit}\")\nif offset:\nquery.append(f\"OFFSET {offset}\")\nreturn \" \".join(query)\n</code></pre>"},{"location":"reference/sqly.queries/#sqly.queries.UPDATE","title":"<code>UPDATE(relation, data, filters)</code>","text":"<p>Build an UPDATE query with the following form: <pre><code>UPDATE relation\nSET (assigns(data))\nWHERE (filters)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>str</code> <p>The name of the table to UPDATE.</p> required <code>data</code> <code>Iterable</code> <p>An iterable representing field names to update.</p> required <code>filters</code> <code>Iterable</code> <p>An iterable of strings represent WHERE filters. At least one filter is required.</p> required <p>Returns:</p> Name Type Description <code>sql</code> <code>str</code> <p>The string representing the SELECT query.</p> Source code in <code>sqly/queries.py</code> <pre><code>def UPDATE(relation: str, data: Iterable, filters: Iterable[str]) -&gt; str:\n\"\"\"\n    Build an UPDATE query with the following form:\n    ```sql\n    UPDATE relation\n    SET (assigns(data))\n    WHERE (filters)\n    ```\n    Arguments:\n        relation (str): The name of the table to UPDATE.\n        data (Iterable): An iterable representing field names to update.\n        filters (Iterable): An iterable of strings represent WHERE filters. At least one\n            filter is required.\n    Returns:\n        sql (str): The string representing the SELECT query.\n    \"\"\"\nquery = [\nf\"UPDATE {relation}\",\nf\"SET {Q.assigns(data)}\",\nf\"WHERE {' AND '.join(filters)}\",\n]\nreturn \" \".join(query)\n</code></pre>"},{"location":"reference/sqly.query/","title":"sqly.query","text":""},{"location":"reference/sqly.query/#sqly.query.Q","title":"<code>Q</code>","text":"<p>Convenience methods for building dynamic queries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = {\"name\": \"Cheeseshop\"}\n&gt;&gt;&gt; f\"INSERT INTO tablename ({Q.fields(d)}) VALUES ({Q.params(d)})\"\n'INSERT INTO tablename (name) VALUES (:name)'\n&gt;&gt;&gt; f\"SELECT ({Q.fields(d)}) FROM tablename WHERE {Q.filter('name')}\"\n'SELECT (name) FROM tablename WHERE name = :name'\n&gt;&gt;&gt; \" \".join([\n...     \"UPDATE tablename SET\",\n...     Q.assigns(['name']),\n...     \"WHERE\",\n...     Q.filter('id'),\n... ])\n'UPDATE tablename SET name = :name WHERE id = :id'\n&gt;&gt;&gt; f\"DELETE FROM tablename WHERE {Q.filter('name')}\"\n'DELETE FROM tablename WHERE name = :name'\n</code></pre> Source code in <code>sqly/query.py</code> <pre><code>class Q:\n\"\"\"\n    Convenience methods for building dynamic queries.\n    Examples:\n        &gt;&gt;&gt; d = {\"name\": \"Cheeseshop\"}\n        &gt;&gt;&gt; f\"INSERT INTO tablename ({Q.fields(d)}) VALUES ({Q.params(d)})\"\n        'INSERT INTO tablename (name) VALUES (:name)'\n        &gt;&gt;&gt; f\"SELECT ({Q.fields(d)}) FROM tablename WHERE {Q.filter('name')}\"\n        'SELECT (name) FROM tablename WHERE name = :name'\n        &gt;&gt;&gt; \" \".join([\n        ...     \"UPDATE tablename SET\",\n        ...     Q.assigns(['name']),\n        ...     \"WHERE\",\n        ...     Q.filter('id'),\n        ... ])\n        'UPDATE tablename SET name = :name WHERE id = :id'\n        &gt;&gt;&gt; f\"DELETE FROM tablename WHERE {Q.filter('name')}\"\n        'DELETE FROM tablename WHERE name = :name'\n    \"\"\"\n@classmethod\ndef keys(cls, fields: Iterable) -&gt; list:\n\"\"\"\n        Return a list of field names from the given iterator.\n        Arguments:\n            fields (Iterable): An iterable of field names. (Can be a Mapping with field\n                names as keys.)\n        Returns:\n            (list): A list of field names\n        Examples:\n            &gt;&gt;&gt; Q.keys({'id': 1, 'name': 'Mark'})\n            ['id', 'name']\n        \"\"\"\nreturn list(fields)\n@classmethod\ndef fields(cls, fields: Iterable) -&gt; str:\n\"\"\"\n        Render a comma-separated string of field names from the given fields. Use: E.g.,\n        for dynamically specifying SELECT or INSERT field lists.\n        Arguments:\n            fields (Iterable): An iterable of field names. (Can be a Mapping with field\n                names as keys.)\n        Returns:\n            (str): A comma-separated string of field names\n        Examples:\n            &gt;&gt;&gt; Q.fields({'id': 1, 'name': 'Mark'})\n            'id, name'\n        \"\"\"\nreturn \", \".join(fields)\n@classmethod\ndef params(cls, fields: Iterable) -&gt; str:\n\"\"\"\n        Render a comma-separated list of parameters from the given fields. Use: E.g.,\n        dynamically specifying INSERT parameter lists.\n        Arguments:\n            fields (Iterable): An iterable of field names. (Can be a Mapping with field\n                names as keys.)\n        Returns:\n            (str): A comma-separated string of field names\n        Examples:\n            &gt;&gt;&gt; Q.params({'id': 1, 'name': 'Mark'})\n            ':id, :name'\n        \"\"\"\nreturn \", \".join(f\":{key}\" for key in cls.keys(fields))\n@classmethod\ndef assigns(cls, fields: Iterable) -&gt; str:\n\"\"\"\n        Render a comma-separated list of assignments from the given fields. Use: E.g.,\n        for dynamically specifying UPDATE field lists.\n        Arguments:\n            fields (Iterable): An iterable of field names. (Can be a Mapping with field\n                names as keys.)\n        Returns:\n            (str): A comma-separated string of field `key = :key` assignments\n        Examples:\n            &gt;&gt;&gt; Q.assigns({'id': 1, 'name': 'Mark'})\n            'id = :id, name = :name'\n        \"\"\"\nreturn \", \".join(f\"{key} = :{key}\" for key in cls.keys(fields))\n@classmethod\ndef filter(cls, field: str, *, op: Optional[str] = \"=\"):\n\"\"\"\n        Render a filter from the given field, optional operator, and optional value.\n        Arguments:\n            field (str): The name of the field.\n            op (str): The operator to use in the filter.\n        Returns:\n            (str): A comma-separated string of field names\n        Examples:\n            &gt;&gt;&gt; Q.filter('id', op='&gt;')\n            'id &gt; :id'\n        \"\"\"\nreturn f\"{field} {op} :{field}\"\n</code></pre>"},{"location":"reference/sqly.query/#sqly.query.Q.assigns","title":"<code>assigns(fields)</code>  <code>classmethod</code>","text":"<p>Render a comma-separated list of assignments from the given fields. Use: E.g., for dynamically specifying UPDATE field lists.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Iterable</code> <p>An iterable of field names. (Can be a Mapping with field names as keys.)</p> required <p>Returns:</p> Type Description <code>str</code> <p>A comma-separated string of field <code>key = :key</code> assignments</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Q.assigns({'id': 1, 'name': 'Mark'})\n'id = :id, name = :name'\n</code></pre> Source code in <code>sqly/query.py</code> <pre><code>@classmethod\ndef assigns(cls, fields: Iterable) -&gt; str:\n\"\"\"\n    Render a comma-separated list of assignments from the given fields. Use: E.g.,\n    for dynamically specifying UPDATE field lists.\n    Arguments:\n        fields (Iterable): An iterable of field names. (Can be a Mapping with field\n            names as keys.)\n    Returns:\n        (str): A comma-separated string of field `key = :key` assignments\n    Examples:\n        &gt;&gt;&gt; Q.assigns({'id': 1, 'name': 'Mark'})\n        'id = :id, name = :name'\n    \"\"\"\nreturn \", \".join(f\"{key} = :{key}\" for key in cls.keys(fields))\n</code></pre>"},{"location":"reference/sqly.query/#sqly.query.Q.fields","title":"<code>fields(fields)</code>  <code>classmethod</code>","text":"<p>Render a comma-separated string of field names from the given fields. Use: E.g., for dynamically specifying SELECT or INSERT field lists.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Iterable</code> <p>An iterable of field names. (Can be a Mapping with field names as keys.)</p> required <p>Returns:</p> Type Description <code>str</code> <p>A comma-separated string of field names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Q.fields({'id': 1, 'name': 'Mark'})\n'id, name'\n</code></pre> Source code in <code>sqly/query.py</code> <pre><code>@classmethod\ndef fields(cls, fields: Iterable) -&gt; str:\n\"\"\"\n    Render a comma-separated string of field names from the given fields. Use: E.g.,\n    for dynamically specifying SELECT or INSERT field lists.\n    Arguments:\n        fields (Iterable): An iterable of field names. (Can be a Mapping with field\n            names as keys.)\n    Returns:\n        (str): A comma-separated string of field names\n    Examples:\n        &gt;&gt;&gt; Q.fields({'id': 1, 'name': 'Mark'})\n        'id, name'\n    \"\"\"\nreturn \", \".join(fields)\n</code></pre>"},{"location":"reference/sqly.query/#sqly.query.Q.filter","title":"<code>filter(field, *, op='=')</code>  <code>classmethod</code>","text":"<p>Render a filter from the given field, optional operator, and optional value.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The name of the field.</p> required <code>op</code> <code>str</code> <p>The operator to use in the filter.</p> <code>'='</code> <p>Returns:</p> Type Description <code>str</code> <p>A comma-separated string of field names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Q.filter('id', op='&gt;')\n'id &gt; :id'\n</code></pre> Source code in <code>sqly/query.py</code> <pre><code>@classmethod\ndef filter(cls, field: str, *, op: Optional[str] = \"=\"):\n\"\"\"\n    Render a filter from the given field, optional operator, and optional value.\n    Arguments:\n        field (str): The name of the field.\n        op (str): The operator to use in the filter.\n    Returns:\n        (str): A comma-separated string of field names\n    Examples:\n        &gt;&gt;&gt; Q.filter('id', op='&gt;')\n        'id &gt; :id'\n    \"\"\"\nreturn f\"{field} {op} :{field}\"\n</code></pre>"},{"location":"reference/sqly.query/#sqly.query.Q.keys","title":"<code>keys(fields)</code>  <code>classmethod</code>","text":"<p>Return a list of field names from the given iterator.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Iterable</code> <p>An iterable of field names. (Can be a Mapping with field names as keys.)</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of field names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Q.keys({'id': 1, 'name': 'Mark'})\n['id', 'name']\n</code></pre> Source code in <code>sqly/query.py</code> <pre><code>@classmethod\ndef keys(cls, fields: Iterable) -&gt; list:\n\"\"\"\n    Return a list of field names from the given iterator.\n    Arguments:\n        fields (Iterable): An iterable of field names. (Can be a Mapping with field\n            names as keys.)\n    Returns:\n        (list): A list of field names\n    Examples:\n        &gt;&gt;&gt; Q.keys({'id': 1, 'name': 'Mark'})\n        ['id', 'name']\n    \"\"\"\nreturn list(fields)\n</code></pre>"},{"location":"reference/sqly.query/#sqly.query.Q.params","title":"<code>params(fields)</code>  <code>classmethod</code>","text":"<p>Render a comma-separated list of parameters from the given fields. Use: E.g., dynamically specifying INSERT parameter lists.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Iterable</code> <p>An iterable of field names. (Can be a Mapping with field names as keys.)</p> required <p>Returns:</p> Type Description <code>str</code> <p>A comma-separated string of field names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Q.params({'id': 1, 'name': 'Mark'})\n':id, :name'\n</code></pre> Source code in <code>sqly/query.py</code> <pre><code>@classmethod\ndef params(cls, fields: Iterable) -&gt; str:\n\"\"\"\n    Render a comma-separated list of parameters from the given fields. Use: E.g.,\n    dynamically specifying INSERT parameter lists.\n    Arguments:\n        fields (Iterable): An iterable of field names. (Can be a Mapping with field\n            names as keys.)\n    Returns:\n        (str): A comma-separated string of field names\n    Examples:\n        &gt;&gt;&gt; Q.params({'id': 1, 'name': 'Mark'})\n        ':id, :name'\n    \"\"\"\nreturn \", \".join(f\":{key}\" for key in cls.keys(fields))\n</code></pre>"},{"location":"reference/sqly.sql/","title":"sqly.sql","text":""},{"location":"reference/sqly.sql/#sqly.sql.SQL","title":"<code>SQL</code>  <code>dataclass</code>","text":"<p>Render and execute SQL queries with a given database dialect. All queries are rendered according to the requirements of that dialect.</p> <ul> <li>Create queries using the ergonomic \u201cnamed\u201d parameter format (:key).</li> <li><code>render()</code> the query to the parameter format native to the current database   Dialect.</li> <li>Use the <code>execute()</code> and <code>select()</code> query methods to <code>render()</code> and execute queries   with \u201cnamed\u201d parameters on the given database connection.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Dialect</code> <p>The SQL dialect used by this database.</p> required <p>Methods:</p> <ul> <li>render(): Render a query and accompanying data to   database Dialect-native form.</li> <li>execute(): Execute a query on the given connection.</li> <li>select(): Execute a query and select the results as     record objects.</li> </ul> <p>Examples:</p> <p>Initialize the SQL and Connection instances:</p> <pre><code>&gt;&gt;&gt; import sqlite3\n&gt;&gt;&gt; from sqly import SQL\n&gt;&gt;&gt; connection = sqlite3.connect(\":memory:\")\n&gt;&gt;&gt; sql = SQL(dialect=\"sqlite\")\n</code></pre> <p>Create a table to make queries with:</p> <pre><code>&gt;&gt;&gt; cursor = sql.execute(connection,\n...     \"CREATE TABLE widgets (id int, sku varchar)\")\n</code></pre> <p>Insert a widget:</p> <pre><code>&gt;&gt;&gt; widget = {\"id\": 1, \"sku\": \"COG-01\"}\n&gt;&gt;&gt; cursor = sql.execute(cursor,  # &lt;-- cursor can be re-used\n...     \"INSERT INTO widgets VALUES (:id, :sku)\", widget)\n&gt;&gt;&gt; connection.commit()\n</code></pre> <p>Select matching widgets:</p> <pre><code>&gt;&gt;&gt; records = sql.select(connection,\n...     \"SELECT * FROM widgets WHERE sku like :sku\", {\"sku\": \"COG-%\"})\n&gt;&gt;&gt; for record in records: print(record)\n{'id': 1, 'sku': 'COG-01'}\n</code></pre> Source code in <code>sqly/sql.py</code> <pre><code>@dataclass\nclass SQL:\n\"\"\"\n    Render and execute SQL queries with a given database dialect. All queries are\n    rendered according to the requirements of that dialect.\n    * Create queries using the ergonomic \"named\" parameter format (:key).\n    * `render()` the query to the parameter format native to the current database\n      Dialect.\n    * Use the `execute()` and `select()` query methods to `render()` and execute queries\n      with \"named\" parameters on the given database connection.\n    Arguments:\n        dialect (Dialect): The SQL [dialect](sqly.dialect.md) used by this database.\n    **Methods:**\n    * [render()](./#sqly.sql.SQL.render): Render a query and accompanying data to\n      database Dialect-native form.\n    * [execute()](./#sqly.sql.SQL.execute): Execute a query on the given connection.\n    * [select()](./#sqly.sql.SQL.select): Execute a query and select the results as\n        record objects.\n    Examples:\n        Initialize the SQL and Connection instances:\n        &gt;&gt;&gt; import sqlite3\n        &gt;&gt;&gt; from sqly import SQL\n        &gt;&gt;&gt; connection = sqlite3.connect(\":memory:\")\n        &gt;&gt;&gt; sql = SQL(dialect=\"sqlite\")\n        Create a table to make queries with:\n        &gt;&gt;&gt; cursor = sql.execute(connection,\n        ...     \"CREATE TABLE widgets (id int, sku varchar)\")\n        Insert a widget:\n        &gt;&gt;&gt; widget = {\"id\": 1, \"sku\": \"COG-01\"}\n        &gt;&gt;&gt; cursor = sql.execute(cursor,  # &lt;-- cursor can be re-used\n        ...     \"INSERT INTO widgets VALUES (:id, :sku)\", widget)\n        &gt;&gt;&gt; connection.commit()\n        Select matching widgets:\n        &gt;&gt;&gt; records = sql.select(connection,\n        ...     \"SELECT * FROM widgets WHERE sku like :sku\", {\"sku\": \"COG-%\"})\n        &gt;&gt;&gt; for record in records: print(record)\n        {'id': 1, 'sku': 'COG-01'}\n    \"\"\"\ndialect: Dialect\ndef __post_init__(self):\nif not isinstance(self.dialect, Dialect):\nself.dialect = Dialect(self.dialect)\ndef render(self, query, data=None):\n\"\"\"\n        Render a query string and its parameters for this SQL dialect.\n        Arguments:\n            query (str | Iterator): a string or iterator of strings.\n            data (Mapping): a keyword dict used to render the query parameters.\n        Returns:\n            (str): the rendered query string.\n            (tuple | dict): depends on the param format:\n                - positional param formats (QMARK, NUMBERED) return a tuple of values\n                - named param formats (NAMED, PYFORMAT) return a dict\n        \"\"\"\n# ordered list of fields for positional outputs (closure for replace_parameter)\nfields = []\ndef replace_parameter(match):\nfield = match.group(1)\n# Build the ordered fields list\nif self.dialect.param_format.is_positional or field not in fields:\nfields.append(field)\n# Return the field formatted for the param format type\nif self.dialect.param_format == ParamFormat.NAMED:\nreturn f\":{field}\"\nelif self.dialect.param_format == ParamFormat.PYFORMAT:\nreturn f\"%({field})s\"\nelif self.dialect.param_format == ParamFormat.QMARK:\nreturn \"?\"\nelif self.dialect.param_format == ParamFormat.NUMBERED:\nreturn f\"${len(fields)}\"\nelse:  # self.dialect.param_format == ParamFormat.FORMAT:\nreturn \"%s\"\n# 1. Convert query to a string\nif isinstance(query, str):\nquery_str = str(query)\nelif hasattr(query, \"__iter__\"):\nquery_str = \"\\n\".join(str(q) for q in walk(query))\nelse:\nraise ValueError(f\"Query has unsupported type: {type(query)}\")\n# 2. Escape string parameters in the PYFORMAT param format\nif self.dialect.param_format == ParamFormat.PYFORMAT:\n# any % must be intended as literal and must be doubled\nquery_str = query_str.replace(\"%\", \"%%\")\n# 3. Replace the parameter with its dialect-specific representation\npattern = r\"(?&lt;!\\\\):(\\w+)\\b\"  # colon + word not preceded by a backslash\nquery_str = re.sub(pattern, replace_parameter, query_str).strip()\n# 4. Un-escape remaining escaped colon params\nif self.dialect.param_format == ParamFormat.NAMED:\n# replace \\:word with :word because the colon-escape is no longer needed.\nquery_str = re.sub(r\"\\\\:(\\w+)\\b\", r\":\\1\", query_str)\n# 5. Build the parameter_values dict or list for use with the query\nif self.dialect.param_format.is_positional:\n# parameter_values is a list of values\nparameter_values = [\njson.dumps(val) if isinstance(val, dict) else val\nfor val in [data[field] for field in fields]\n]\nelse:\n# parameter_values is a dict of key:value fields\nparameter_values = {\nkey: json.dumps(val) if isinstance(val, (dict, list, tuple)) else val\nfor key, val in {field: data[field] for field in fields}.items()\n}\n# 6. Return a tuple formatted for this Dialect\n# if self.dialect == Dialect.ASYNCPG:\n# asyncpg expects the parameters in a tuple following the query string.\n# return tuple([query_str] + parameter_values)\n# else:\n# other dialects expect the parameters in the second tuple item.\nreturn (query_str, parameter_values)\ndef execute(\nself, connection: Any, query: str | Iterator, data: Optional[Mapping] = None\n):\n\"\"\"\n        Execute the given query on the connection and return the connection cursor.\n        If the query fails: Rollback the connection and re-raise the exception, as a\n        convenience to the user not to leave the connection in an unusable state.\n        If `.execute()` is called with a previously-generated cursor, that cursor will\n        be reused and the same cursor returned from the method call.\n        Parameters:\n            connection (Connection | Cursor): A DB-API 2.0 compliant database connection\n                or cursor.\n            query (str | Iterator): A query that will be rendered with the given data.\n            data (Optional[Mapping]): A data mapping that will be rendered as params\n                with the query. Optional, but required if the query contains parameters.\n        Returns:\n            cursor (Cursor): A DB-API 2.0 compliant database cursor.\n        \"\"\"\ntry:\ncursor = connection.execute(*self.render(query, data))\nexcept Exception as exc:\n# If the connection is a cursor, get the underlying connection to rollback,\n# because cursors don't have a rollback method.\nif hasattr(connection, \"connection\"):\nconnection = connection.connection\nconnection.rollback()\nraise exc\nreturn cursor\ndef select(\nself,\nconnection: Any,\nquery: str | Iterator,\ndata: Optional[Mapping] = None,\nConstructor=dict,\n):\n\"\"\"\n        Execute the given query on the connection, and yield result records.\n        The `.select()` method is a generator which iterates over a native database\n        cursor. The results of the method can be cast to a list via `list(...)` or can\n        be iterated through one at a time.\n        If the query fails: Rollback the connection and re-raise the exception, as a\n        convenience to the user not to leave the connection in an unusable state.\n        Parameters:\n            connection (Connection | Cursor): A DB-API 2.0 compliant database connection\n                or cursor.\n            query (str | Iterator): A query that will be rendered with the given data.\n            data (Optional[Mapping]): A data mapping that will be rendered as params\n                with the query. Optional, but required if the query contains parameters.\n            Constructor (class): A constructor to use to build records from the results.\n                The constructor must take the results of `zip(keys, values)` as its\n                argument.\n        Yields:\n            record (Mapping): A mapping object that contains a database record.\n        \"\"\"\ncursor = self.execute(connection, query, data)\nfields = [d[0] for d in cursor.description]\nfor row in cursor:\nyield Constructor(zip(fields, row))\n</code></pre>"},{"location":"reference/sqly.sql/#sqly.sql.SQL.execute","title":"<code>execute(connection, query, data=None)</code>","text":"<p>Execute the given query on the connection and return the connection cursor.</p> <p>If the query fails: Rollback the connection and re-raise the exception, as a convenience to the user not to leave the connection in an unusable state.</p> <p>If <code>.execute()</code> is called with a previously-generated cursor, that cursor will be reused and the same cursor returned from the method call.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection | Cursor</code> <p>A DB-API 2.0 compliant database connection or cursor.</p> required <code>query</code> <code>str | Iterator</code> <p>A query that will be rendered with the given data.</p> required <code>data</code> <code>Optional[Mapping]</code> <p>A data mapping that will be rendered as params with the query. Optional, but required if the query contains parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>cursor</code> <code>Cursor</code> <p>A DB-API 2.0 compliant database cursor.</p> Source code in <code>sqly/sql.py</code> <pre><code>def execute(\nself, connection: Any, query: str | Iterator, data: Optional[Mapping] = None\n):\n\"\"\"\n    Execute the given query on the connection and return the connection cursor.\n    If the query fails: Rollback the connection and re-raise the exception, as a\n    convenience to the user not to leave the connection in an unusable state.\n    If `.execute()` is called with a previously-generated cursor, that cursor will\n    be reused and the same cursor returned from the method call.\n    Parameters:\n        connection (Connection | Cursor): A DB-API 2.0 compliant database connection\n            or cursor.\n        query (str | Iterator): A query that will be rendered with the given data.\n        data (Optional[Mapping]): A data mapping that will be rendered as params\n            with the query. Optional, but required if the query contains parameters.\n    Returns:\n        cursor (Cursor): A DB-API 2.0 compliant database cursor.\n    \"\"\"\ntry:\ncursor = connection.execute(*self.render(query, data))\nexcept Exception as exc:\n# If the connection is a cursor, get the underlying connection to rollback,\n# because cursors don't have a rollback method.\nif hasattr(connection, \"connection\"):\nconnection = connection.connection\nconnection.rollback()\nraise exc\nreturn cursor\n</code></pre>"},{"location":"reference/sqly.sql/#sqly.sql.SQL.render","title":"<code>render(query, data=None)</code>","text":"<p>Render a query string and its parameters for this SQL dialect.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | Iterator</code> <p>a string or iterator of strings.</p> required <code>data</code> <code>Mapping</code> <p>a keyword dict used to render the query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the rendered query string.</p> <code>tuple | dict</code> <p>depends on the param format:</p> <ul> <li>positional param formats (QMARK, NUMBERED) return a tuple of values</li> <li>named param formats (NAMED, PYFORMAT) return a dict</li> </ul> Source code in <code>sqly/sql.py</code> <pre><code>def render(self, query, data=None):\n\"\"\"\n    Render a query string and its parameters for this SQL dialect.\n    Arguments:\n        query (str | Iterator): a string or iterator of strings.\n        data (Mapping): a keyword dict used to render the query parameters.\n    Returns:\n        (str): the rendered query string.\n        (tuple | dict): depends on the param format:\n            - positional param formats (QMARK, NUMBERED) return a tuple of values\n            - named param formats (NAMED, PYFORMAT) return a dict\n    \"\"\"\n# ordered list of fields for positional outputs (closure for replace_parameter)\nfields = []\ndef replace_parameter(match):\nfield = match.group(1)\n# Build the ordered fields list\nif self.dialect.param_format.is_positional or field not in fields:\nfields.append(field)\n# Return the field formatted for the param format type\nif self.dialect.param_format == ParamFormat.NAMED:\nreturn f\":{field}\"\nelif self.dialect.param_format == ParamFormat.PYFORMAT:\nreturn f\"%({field})s\"\nelif self.dialect.param_format == ParamFormat.QMARK:\nreturn \"?\"\nelif self.dialect.param_format == ParamFormat.NUMBERED:\nreturn f\"${len(fields)}\"\nelse:  # self.dialect.param_format == ParamFormat.FORMAT:\nreturn \"%s\"\n# 1. Convert query to a string\nif isinstance(query, str):\nquery_str = str(query)\nelif hasattr(query, \"__iter__\"):\nquery_str = \"\\n\".join(str(q) for q in walk(query))\nelse:\nraise ValueError(f\"Query has unsupported type: {type(query)}\")\n# 2. Escape string parameters in the PYFORMAT param format\nif self.dialect.param_format == ParamFormat.PYFORMAT:\n# any % must be intended as literal and must be doubled\nquery_str = query_str.replace(\"%\", \"%%\")\n# 3. Replace the parameter with its dialect-specific representation\npattern = r\"(?&lt;!\\\\):(\\w+)\\b\"  # colon + word not preceded by a backslash\nquery_str = re.sub(pattern, replace_parameter, query_str).strip()\n# 4. Un-escape remaining escaped colon params\nif self.dialect.param_format == ParamFormat.NAMED:\n# replace \\:word with :word because the colon-escape is no longer needed.\nquery_str = re.sub(r\"\\\\:(\\w+)\\b\", r\":\\1\", query_str)\n# 5. Build the parameter_values dict or list for use with the query\nif self.dialect.param_format.is_positional:\n# parameter_values is a list of values\nparameter_values = [\njson.dumps(val) if isinstance(val, dict) else val\nfor val in [data[field] for field in fields]\n]\nelse:\n# parameter_values is a dict of key:value fields\nparameter_values = {\nkey: json.dumps(val) if isinstance(val, (dict, list, tuple)) else val\nfor key, val in {field: data[field] for field in fields}.items()\n}\n# 6. Return a tuple formatted for this Dialect\n# if self.dialect == Dialect.ASYNCPG:\n# asyncpg expects the parameters in a tuple following the query string.\n# return tuple([query_str] + parameter_values)\n# else:\n# other dialects expect the parameters in the second tuple item.\nreturn (query_str, parameter_values)\n</code></pre>"},{"location":"reference/sqly.sql/#sqly.sql.SQL.select","title":"<code>select(connection, query, data=None, Constructor=dict)</code>","text":"<p>Execute the given query on the connection, and yield result records.</p> <p>The <code>.select()</code> method is a generator which iterates over a native database cursor. The results of the method can be cast to a list via <code>list(...)</code> or can be iterated through one at a time.</p> <p>If the query fails: Rollback the connection and re-raise the exception, as a convenience to the user not to leave the connection in an unusable state.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection | Cursor</code> <p>A DB-API 2.0 compliant database connection or cursor.</p> required <code>query</code> <code>str | Iterator</code> <p>A query that will be rendered with the given data.</p> required <code>data</code> <code>Optional[Mapping]</code> <p>A data mapping that will be rendered as params with the query. Optional, but required if the query contains parameters.</p> <code>None</code> <code>Constructor</code> <code>class</code> <p>A constructor to use to build records from the results. The constructor must take the results of <code>zip(keys, values)</code> as its argument.</p> <code>dict</code> <p>Yields:</p> Name Type Description <code>record</code> <code>Mapping</code> <p>A mapping object that contains a database record.</p> Source code in <code>sqly/sql.py</code> <pre><code>def select(\nself,\nconnection: Any,\nquery: str | Iterator,\ndata: Optional[Mapping] = None,\nConstructor=dict,\n):\n\"\"\"\n    Execute the given query on the connection, and yield result records.\n    The `.select()` method is a generator which iterates over a native database\n    cursor. The results of the method can be cast to a list via `list(...)` or can\n    be iterated through one at a time.\n    If the query fails: Rollback the connection and re-raise the exception, as a\n    convenience to the user not to leave the connection in an unusable state.\n    Parameters:\n        connection (Connection | Cursor): A DB-API 2.0 compliant database connection\n            or cursor.\n        query (str | Iterator): A query that will be rendered with the given data.\n        data (Optional[Mapping]): A data mapping that will be rendered as params\n            with the query. Optional, but required if the query contains parameters.\n        Constructor (class): A constructor to use to build records from the results.\n            The constructor must take the results of `zip(keys, values)` as its\n            argument.\n    Yields:\n        record (Mapping): A mapping object that contains a database record.\n    \"\"\"\ncursor = self.execute(connection, query, data)\nfields = [d[0] for d in cursor.description]\nfor row in cursor:\nyield Constructor(zip(fields, row))\n</code></pre>"}]}